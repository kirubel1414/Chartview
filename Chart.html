<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Free Crypto Advanced Chart (CoinGecko + Lightweight Charts)</title>

  <!-- Lightweight Charts (TradingView) standalone build from CDN -->
  <script src="https://unpkg.com/lightweight-charts@4.4.0/dist/lightweight-charts.standalone.production.js"></script>

  <style>
    :root{
      --bg:#0f1724; --panel:#0b1220; --muted:#9aa7c7; --accent:#1fb6ff;
      --card:#0e1624; --glass: rgba(255,255,255,0.03);
    }
    html,body{height:100%;margin:0;font-family:Inter, Roboto, system-ui, Arial;color:#e6eef8;background:linear-gradient(180deg,#071025 0%, #071a2f 100%);}
    .app{
      max-width:1200px;margin:18px auto;padding:16px;box-sizing:border-box;
    }
    header{display:flex;gap:12px;align-items:center;margin-bottom:12px;}
    .brand{font-weight:700;font-size:18px;color:var(--accent);}
    .controls{display:flex;gap:8px;align-items:center;margin-left:auto;}
    .controls input[type="text"]{padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:var(--glass);color:inherit}
    select, button{padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:inherit}
    button{cursor:pointer}
    .meta{margin-top:6px;color:var(--muted);font-size:13px;}
    .layout{display:grid;grid-template-columns:1fr 320px;gap:12px;height:75vh;}
    .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:10px;padding:12px;box-sizing:border-box;box-shadow:0 6px 18px rgba(2,6,23,0.6);display:flex;flex-direction:column}
    #chart{flex:1;min-height:0;padding:6px;}
    .side{display:flex;flex-direction:column;gap:8px;overflow:auto}
    .stat{display:flex;justify-content:space-between;padding:8px;border-radius:8px;background:rgba(255,255,255,0.01);font-size:14px}
    .foot{font-size:13px;color:var(--muted);margin-top:8px}
    label{font-size:13px;color:var(--muted)}
    .small{font-size:12px;color:var(--muted)}
    .timeframes{display:flex;gap:6px}
    .timeframes button{background:transparent;border-radius:8px;padding:6px 8px;border:1px solid rgba(255,255,255,0.03)}
    .timeframes button.active{background:var(--accent);color:#021426}
    .sma-input{width:72px}
    footer{margin-top:12px;color:var(--muted);font-size:12px;text-align:center}
    @media (max-width:900px){
      .layout{grid-template-columns:1fr; height:70vh}
      .controls{flex-wrap:wrap}
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div class="brand">Free Crypto Advanced Chart</div>
      <div class="meta">Data source: CoinGecko (free, no key). Chart: Lightweight Charts.</div>

      <div class="controls">
        <input id="search" type="text" placeholder="Search coin by name or symbol (eg: bitcoin, btc)" />
        <select id="coin-select"></select>
        <div class="timeframes" id="tf-buttons">
          <button data-days="1" class="active">1D</button>
          <button data-days="7">7D</button>
          <button data-days="30">30D</button>
          <button data-days="90">90D</button>
          <button data-days="365">1Y</button>
        </div>
        <label class="small">SMA</label>
        <input id="sma-period" class="sma-input" type="number" min="1" value="20" />
        <button id="apply-sma">Apply</button>
        <button id="reload">Reload</button>
      </div>
    </header>

    <div class="layout">
      <div class="card">
        <div id="chart"></div>
        <div class="foot">Tip: Click and drag to scroll. Use the timeframes to change history. Live updates poll every 5s.</div>
      </div>

      <div class="card side">
        <div class="stat"><div>Selected</div><div id="selected-coin">bitcoin (btc)</div></div>
        <div class="stat"><div>Last Price (USD)</div><div id="last-price">$—</div></div>
        <div class="stat"><div>24h Change</div><div id="change-24h">—</div></div>
        <div class="stat"><div>Market Cap</div><div id="mktcap">—</div></div>
        <div class="stat"><div>Volume (24h)</div><div id="vol24">—</div></div>
        <div class="stat"><div>Latest Candle</div><div id="last-candle">—</div></div>

        <div style="margin-top:8px">
          <label>Chart events / logs</label>
          <pre id="log" style="height:220px;overflow:auto;background:rgba(0,0,0,0.15);padding:8px;border-radius:8px;color:#bcd;color-wrap:normal"></pre>
        </div>
      </div>
    </div>

    <footer>Built with CoinGecko free API • Lightweight Charts • No API key required</footer>
  </div>

<script>
/*
  Free Crypto Advanced Chart
  - Uses CoinGecko public API (no key)
  - Chart library: TradingView Lightweight Charts (loaded from CDN)
  - Author: ChatGPT (example project)
*/

/* ---------------------------
   Config / Globals
   --------------------------- */
const COINGECKO_BASE = 'https://api.coingecko.com/api/v3';
let coinsList = []; // {id, symbol, name}
let current = { id: 'bitcoin', symbol: 'btc', name: 'Bitcoin', days: 1 };
let pollInterval = 5000; // 5s
let pollTimer = null;
let chart, candleSeries, volumeSeries, smaSeries;
let lastFetchedCandles = []; // keep last candles

/* ---------------------------
   Helpers
   --------------------------- */
function $id(id){ return document.getElementById(id); }
function log(msg){ const el = $id('log'); el.textContent = new Date().toLocaleTimeString() + ' — ' + msg + '\n' + el.textContent; }

/* CoinGecko helpers */
async function fetchJSON(path){
  const res = await fetch(`${COINGECKO_BASE}${path}`);
  if(!res.ok){
    throw new Error('API error: ' + res.status + ' ' + res.statusText);
  }
  return res.json();
}

/* map CoinGecko OHLC (ms timestamp) -> lightweight-charts format (time in seconds) */
function mapOhlcToCandle(ohlcArray){
  // CoinGecko OHLC: [ [timestamp(ms), open, high, low, close], ... ]
  return ohlcArray.map(item => ({
    time: Math.floor(item[0] / 1000),
    open: item[1],
    high: item[2],
    low: item[3],
    close: item[4]
  }));
}

/* compute SMA - expects array of {time, close} or candles; returns [{time, value}] */
function computeSMA(candles, period){
  const res = [];
  if(period <= 0) return res;
  let sum = 0;
  for(let i=0;i<candles.length;i++){
    const price = candles[i].close;
    sum += price;
    if(i >= period) sum -= candles[i-period].close;
    if(i >= period - 1){
      res.push({ time: candles[i].time, value: +(sum / period).toFixed(8) });
    }
  }
  return res;
}

/* ---------------------------
   UI: coin search + select
   --------------------------- */
async function loadCoinsList(){
  log('Downloading coin list from CoinGecko...');
  coinsList = await fetchJSON('/coins/list'); // large list ~ 13k
  // sort by market recognition: prefer well-known by putting common coins first (manual)
  // For simplicity, we'll fill select with a short curated list, then include others via search.
  const curated = ['bitcoin','ethereum','tether','binancecoin','usd-coin','ripple','cardano','dogecoin','polkadot','litecoin'];
  const select = $id('coin-select');
  select.innerHTML = '';
  curated.forEach(id=>{
    const c = coinsList.find(x=>x.id===id);
    if(c) {
      const opt = document.createElement('option'); opt.value = c.id; opt.textContent = `${c.name} (${c.symbol})`; select.appendChild(opt);
    }
  });
  // add current if not included
  if(!Array.from(select.options).some(o=>o.value===current.id)){
    const found = coinsList.find(x=>x.id===current.id);
    if(found){
      const opt = document.createElement('option'); opt.value = found.id; opt.textContent = `${found.name} (${found.symbol})`; select.prepend(opt);
    }
  }
  // when user types in search box, attempt to find best match
  $id('search').addEventListener('input', onSearchInput);
  select.addEventListener('change', async (e) => {
    const id = e.target.value;
    const coin = coinsList.find(x=>x.id===id);
    if(coin){ await selectCoin(coin); }
  });
}

let searchTimer = null;
function onSearchInput(e){
  const q = e.target.value.trim().toLowerCase();
  if(searchTimer) clearTimeout(searchTimer);
  if(!q) return;
  searchTimer = setTimeout(()=>{
    const found = coinsList.find(c => c.id === q || c.symbol === q || c.name.toLowerCase() === q || c.name.toLowerCase().includes(q));
    if(found){ $id('coin-select').value = found.id; selectCoin(found); }
    else log('No exact match found for search: ' + q);
  }, 300);
}

async function selectCoin(coin){
  current.id = coin.id; current.symbol = coin.symbol; current.name = coin.name;
  $id('selected-coin').textContent = `${coin.name} (${coin.symbol})`;
  log('Selected coin: ' + coin.id);
  await loadAndDraw(current.id, current.days);
}

/* ---------------------------
   Chart init and draw
   --------------------------- */
function initChart(){
  const container = $id('chart');
  container.innerHTML = ''; // clear
  chart = LightweightCharts.createChart(container, {
    layout: { background: { color: '#071025' }, textColor: '#e6eef8' },
    rightPriceScale: { borderVisible: false },
    timeScale: { borderVisible: false, timeVisible: true, secondsVisible: false },
    crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
    grid: { vertLines: { visible: false }, horzLines: { color: 'rgba(255,255,255,0.03)' } },
    handleScroll: { mouseWheel: true, pressedMouseMove: true },
    handleScale: { axisPressedMouseMove: true, pinch: true }
  });

  candleSeries = chart.addCandlestickSeries({
    upColor: '#26a69a', downColor: '#ef5350', borderVisible: false, wickVisible: true, priceLineVisible: false
  });

  // volume series (histogram)
  volumeSeries = chart.addHistogramSeries({
    color: 'rgba(255,255,255,0.2)', priceFormat: { type: 'volume' }, scaleMargins: { top: 0.8, bottom: 0 }
  });
  // SMA line
  smaSeries = chart.addLineSeries({ color: '#f6c85f', lineWidth: 2 });

  // synchronize volume scale: map to same time scale but separate price scale - but for lightweight-charts,
  // using histogram series is okay; we will feed time/value pairs.
  chart.timeScale().fitContent();
}

/* Draw candles + volume + compute sma */
async function loadAndDraw(coinId, days){
  try{
    log(`Fetching OHLC for ${coinId}, days=${days} ...`);
    // OHLC endpoint supports specific days values: 1,7,14,30,90,180,365
    const allowed = [1,7,14,30,90,180,365];
    const daysParam = allowed.includes(days) ? days : (days <= 7 ? 7 : 30);

    // fetch OHLC
    const ohlc = await fetchJSON(`/coins/${coinId}/ohlc?vs_currency=usd&days=${daysParam}`);
    const candles = mapOhlcToCandle(ohlc);
    lastFetchedCandles = candles;

    // fetch market_chart for volumes and additional stats (24h change, marketcap)
    const mc = await fetchJSON(`/coins/${coinId}/market_chart?vs_currency=usd&days=${daysParam}&interval=hourly`);
    // mc.prices: [ [ms, price], ... ], mc.total_volumes: [ [ms, vol], ... ]
    const vols = (mc.total_volumes || []).map(v => ({ time: Math.floor(v[0]/1000), value: +v[1].toFixed(2) }));

    // set data
    candleSeries.setData(candles);
    // volumeSeries wants bars with time and value relative to histogram; we'll normalize moderately:
    // use raw volume values but chart will auto-scale
    volumeSeries.setData(vols);

    // set SMA
    applySMA();

    // fetch coin market data for stats
    const coinData = await fetchJSON(`/coins/${coinId}?localization=false&tickers=false&market_data=true&community_data=false&developer_data=false&sparkline=false`);
    updateStats(coinData);

    chart.timeScale().fitContent();
    log(`Loaded ${candles.length} candles for ${coinId}.`);
    // start polling for live updates
    restartPolling();
  }catch(err){
    console.error(err);
    log('Error loading chart: ' + err.message);
  }
}

function updateStats(coinData){
  try{
    const m = coinData.market_data;
    $id('last-price').textContent = m?.current_price?.usd ? '$' + Number(m.current_price.usd).toLocaleString() : '—';
    const ch = m?.price_change_percentage_24h ? m.price_change_percentage_24h.toFixed(2) + '%' : '—';
    $id('change-24h').textContent = ch;
    $id('mktcap').textContent = m?.market_cap?.usd ? '$' + Number(m.market_cap.usd).toLocaleString() : '—';
    $id('vol24').textContent = m?.total_volume?.usd ? '$' + Number(m.total_volume.usd).toLocaleString() : '—';
    // latest candle
    const lc = lastFetchedCandles.length ? lastFetchedCandles[lastFetchedCandles.length-1] : null;
    if(lc) $id('last-candle').textContent = `${new Date(lc.time*1000).toLocaleString()} O:${lc.open} H:${lc.high} L:${lc.low} C:${lc.close}`;
  }catch(e){
    console.warn('updateStats err', e);
  }
}

/* ---------------------------
   Live polling / update last candle
   --------------------------- */
function restartPolling(){
  if(pollTimer) clearInterval(pollTimer);
  pollTimer = setInterval(async ()=>{
    try{
      // fetch latest minute prices for 1 day then derive last candle or last price
      const mc = await fetchJSON(`/coins/${current.id}/market_chart?vs_currency=usd&days=1&interval=minutely`);
      const prices = mc.prices || [];
      if(prices.length === 0) return;
      // convert prices array to time ordered points; each element [ms, price]
      // We'll update the last candle in lastFetchedCandles by inspecting last two minutes.
      const lastPricePoint = prices[prices.length-1];
      const timeSec = Math.floor(lastPricePoint[0] / 1000);
      const lastPrice = lastPricePoint[1];

      // If lastFetchedCandles empty, skip
      if(!lastFetchedCandles || lastFetchedCandles.length === 0) return;

      // Determine if timeSec belongs to last candle (same minute or same hour depending on timeframe)
      const lastCandle = lastFetchedCandles[lastFetchedCandles.length - 1];
      // If timeframe is 1 day with minute granularity, candles may represent minute/hour depending on API.
      // For simplicity, we'll update last candle's close to latest price and adjust high/low.
      if(timeSec >= lastCandle.time){
        // update
        lastCandle.close = lastPrice;
        if(lastPrice > lastCandle.high) lastCandle.high = lastPrice;
        if(lastPrice < lastCandle.low) lastCandle.low = lastPrice;
        if(timeSec > lastCandle.time + 60*5){ // if significant time advanced, append a new candle (fallback)
          lastFetchedCandles.push({ time: timeSec, open: lastPrice, high: lastPrice, low: lastPrice, close: lastPrice });
        }
      } else {
        // time moved backward? ignore
      }
      // update chart series
      candleSeries.update(lastCandle);
      // update stats display price
      $id('last-price').textContent = '$' + Number(lastPrice).toLocaleString();
      $id('last-candle').textContent = `${new Date(lastCandle.time*1000).toLocaleString()} O:${lastCandle.open} H:${lastCandle.high} L:${lastCandle.low} C:${lastCandle.close}`;
      // recompute SMA tail
      applySMA(true);
      log('Polled latest price: $' + lastPrice.toFixed(2));
    }catch(err){
      console.warn('poll err', err);
      log('Poll error: ' + (err.message||err));
    }
  }, pollInterval);
}

/* ---------------------------
   SMA apply
   --------------------------- */
function applySMA(isTailUpdate=false){
  const period = parseInt($id('sma-period').value) || 20;
  const candles = lastFetchedCandles;
  if(!candles || candles.length === 0) return;
  const sma = computeSMA(candles, period);
  if(isTailUpdate && sma.length>0){
    // update only last point
    smaSeries.setData(sma);
  } else {
    smaSeries.setData(sma);
  }
}

/* ---------------------------
   UI wiring
   --------------------------- */
document.addEventListener('DOMContentLoaded', async ()=>{
  initChart();
  await loadCoinsList();

  // default select bitcoin
  const defaultCoin = coinsList.find(c=>c.id==='bitcoin') || coinsList[0];
  if(defaultCoin) {
    $id('coin-select').value = defaultCoin.id;
    selectCoin(defaultCoin);
  }

  // timeframe buttons
  document.getElementById('tf-buttons').addEventListener('click', async (e) => {
    if(e.target.dataset && e.target.dataset.days){
      const days = Number(e.target.dataset.days);
      current.days = days;
      Array.from(document.querySelectorAll('#tf-buttons button')).forEach(b=>b.classList.remove('active'));
      e.target.classList.add('active');
      await loadAndDraw(current.id, days);
    }
  });

  // apply sma
  $id('apply-sma').addEventListener('click', ()=>{ applySMA(); log('Applied SMA period ' + $id('sma-period').value); });

  // reload button
  $id('reload').addEventListener('click', async ()=>{ await loadAndDraw(current.id, current.days); log('Manual reload'); });

  // allow pressing Enter in search to find best match
  $id('search').addEventListener('keydown', (ev) => {
    if(ev.key === 'Enter'){
      const q = ev.target.value.trim().toLowerCase();
      if(!q) return;
      const found = coinsList.find(c => c.id === q || c.symbol === q || c.name.toLowerCase() === q || c.name.toLowerCase().includes(q));
      if(found){ $id('coin-select').value = found.id; selectCoin(found); } else { log('No coin found for: ' + q); }
    }
  });
});

/* ---------------------------
   Prevent leaving timers
   --------------------------- */
window.addEventListener('beforeunload', ()=>{ if(pollTimer) clearInterval(pollTimer); });

</script>
</body>
</html>